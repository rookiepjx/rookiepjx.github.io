<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | Ronan&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/avatar.jpg">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.7b36eabc.css" as="style"><link rel="preload" href="/assets/js/app.5ab2ec69.js" as="script"><link rel="preload" href="/assets/js/2.eeb24f79.js" as="script"><link rel="preload" href="/assets/js/16.551a14fc.js" as="script"><link rel="prefetch" href="/assets/js/10.d0415309.js"><link rel="prefetch" href="/assets/js/11.11f96ddc.js"><link rel="prefetch" href="/assets/js/12.17cdedb4.js"><link rel="prefetch" href="/assets/js/13.b53a64a6.js"><link rel="prefetch" href="/assets/js/14.6127168f.js"><link rel="prefetch" href="/assets/js/15.c6fec423.js"><link rel="prefetch" href="/assets/js/17.3ad529cc.js"><link rel="prefetch" href="/assets/js/18.9da1d026.js"><link rel="prefetch" href="/assets/js/19.0ff8f3e6.js"><link rel="prefetch" href="/assets/js/3.1801cb39.js"><link rel="prefetch" href="/assets/js/4.30c96a68.js"><link rel="prefetch" href="/assets/js/5.f0e2ef51.js"><link rel="prefetch" href="/assets/js/6.e86df8f9.js"><link rel="prefetch" href="/assets/js/7.e76e2440.js"><link rel="prefetch" href="/assets/js/8.8df23d51.js"><link rel="prefetch" href="/assets/js/9.8c479be0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7b36eabc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="Ronan's Blog" class="logo"> <span class="site-name can-hide">Ronan's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Css/" class="nav-link">
  Css
</a></div><div class="nav-item"><a href="/Js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/Js+/" class="nav-link">
  Js高级
</a></div><div class="nav-item"><a href="/Ts/" class="nav-link">
  Ts
</a></div><div class="nav-item"><a href="/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/Network/" class="nav-link">
  Network
</a></div><div class="nav-item"><a href="/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Others/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Others/Nginx/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/Others/Algorithm/" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/Others/粤语/" class="nav-link">
  粤语
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Css/" class="nav-link">
  Css
</a></div><div class="nav-item"><a href="/Js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/Js+/" class="nav-link">
  Js高级
</a></div><div class="nav-item"><a href="/Ts/" class="nav-link">
  Ts
</a></div><div class="nav-item"><a href="/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/Network/" class="nav-link">
  Network
</a></div><div class="nav-item"><a href="/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Others/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Others/Nginx/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/Others/Algorithm/" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/Others/粤语/" class="nav-link">
  粤语
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/React/#jsx的本质" class="sidebar-link">JSX的本质</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#类组件和函数式组件" class="sidebar-link">类组件和函数式组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#react生命周期函数" class="sidebar-link">React生命周期函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#react组件间通信" class="sidebar-link">React组件间通信</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#react插槽的使用" class="sidebar-link">React插槽的使用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#setstate同步异步问题" class="sidebar-link">setState同步异步问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#获取setstate异步更新结果" class="sidebar-link">获取setState异步更新结果</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#setstate的合并" class="sidebar-link">setState的合并</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#setstate不可变性的力量" class="sidebar-link">setState不可变性的力量</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#scu、purecomponent、memo" class="sidebar-link">SCU、PureComponent、memo</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#高阶组件hoc" class="sidebar-link">高阶组件HOC</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#react严格模式" class="sidebar-link">React严格模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#redux及中间件" class="sidebar-link">Redux及中间件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/React/#react中间件redux-thunk" class="sidebar-link">React中间件redux-thunk</a></li></ul></li><li><a href="/React/#封装react-redux的connect函数" class="sidebar-link">封装react-redux的connect函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#前端路由的原理" class="sidebar-link">前端路由的原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#useeffect模拟生命周期函数" class="sidebar-link">useEffect模拟生命周期函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#usememo和usecallback的区别" class="sidebar-link">useMemo和useCallback的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#usestate和usereducer的区别" class="sidebar-link">useState和useReducer的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#useeffect和uselayouteffect的区别" class="sidebar-link">useEffect和useLayoutEffect的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#useimperativehandle" class="sidebar-link">useImperativeHandle</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#usedispatch、useselector、shallowequal" class="sidebar-link">useDispatch、useSelector、shallowEqual</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/React/#redux-toolkit" class="sidebar-link">redux-toolkit</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="jsx的本质"><a href="#jsx的本质" class="header-anchor">#</a> JSX的本质</h2> <p>JSX的本质是<code>React.createElement(type,config,children)</code>函数的语法糖，两种写法效果一样。</p> <p>type:标签类型，config:属性，children:标签中的内容。实际是一个<strong>数组</strong>，虽然只有一个参数代表children，但是实际可以传递多个参数。</p> <p>React.createElement函数的返回值是一个ReactElement对象，<strong>通过这个对象构建js对象树，也就是虚拟DOM</strong></p> <p>children<strong>源码</strong>：</p> <div class="language-react extra-class"><pre class="language-text"><code>const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength &gt; 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i &lt; childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (__DEV__) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }
</code></pre></div><p>babel编译jsx</p> <div class="language-react extra-class"><pre class="language-text"><code>// jsx 通过babel编译成js
&lt;script type=&quot;text/babel&quot;&gt;
    const message1 = &lt;h1&gt;Hello React&lt;/h1&gt;
&lt;script/&gt;

ReactDom.render(message1,document.getElementByid(&quot;#app&quot;))
        
// 不需要babel编译
&lt;script&gt;
    const message2 = React.createElement(&quot;h1&quot;,null,Hello React)
&lt;script/&gt;

ReactDom.render(message2,document.getElementByid(&quot;#app&quot;))
</code></pre></div><p>babel官网编译</p> <p><img src="https://cdn.jsdelivr.net/gh/rookiepjx/image-bed/img/Snipaste_2020-09-27_15-22-47.jpg" alt=""></p> <p><strong>总结</strong>：JSX --babel编译--&gt; creatElement函数 ----&gt; ReacrElement对象（虚拟DOM） --ReactDom.render函数--&gt; 真实DOM</p> <h2 id="类组件和函数式组件"><a href="#类组件和函数式组件" class="header-anchor">#</a> 类组件和函数式组件</h2> <p>类组件</p> <ol><li><p>类组件名是大写字符开头（无论类组件还是函数组件）</p></li> <li><p>类组件需要继承自 React.Component</p></li> <li><p>类组件必须实现render函数</p></li></ol> <p>函数式组件</p> <ol><li>函数式组件没有<code>this</code>对象</li> <li>函数式组件没有内部状态<code>state</code>(useState解决)</li> <li>函数值组件没有<code>生命周期函数</code>（useEffect解决）</li></ol> <h2 id="react生命周期函数"><a href="#react生命周期函数" class="header-anchor">#</a> React生命周期函数</h2> <p>生命周期函数是<strong>Class类组件中的概念</strong>，function函数式组件没有生命周期函数的概念。函数式组件可以使用hooks模拟生命周期函数。</p> <p>react生命周期有15和16两种版本。后续17版本也会有变化。</p> <p><strong>15版本</strong></p> <ol><li>初始化（initialization）</li> <li>挂载阶段（Mounting）</li> <li>更新阶段（Updating）</li> <li>卸载阶段（unmounting）</li></ol> <p><strong>16版本</strong></p> <ol><li><p>挂载阶段 - 组件实例被创建和插入 DOM 树的过程</p></li> <li><p>更新阶段 - 组件被重新渲染的过程</p></li> <li><p>卸载阶段 - 组件从 DOM 树中被删除的过程</p></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/rookiepjx/image-bed/img/Snipaste_2020-09-25_22-46-52.jpg" alt=""></p> <p><strong>constructor</strong></p> <ul><li>初始化内部state</li> <li>为事件绑定实例this</li></ul> <p><strong>getDerivedStateFromProps</strong></p> <ul><li>state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state</li></ul> <p><strong>shouldComponentUpdate（SCU）</strong></p> <ul><li><p>常用于性能优化。返回一个布尔值。<strong>在组件接收到新的props或者state时被调用</strong>。在初始化时或者使用forceUpdate时不被调用。</p> <p>在<strong>PureComponent</strong>中自动实现了此方法</p></li></ul> <p><strong>render</strong></p> <ul><li>执行渲染</li></ul> <p><strong>getSnapshotBeforeUpdate</strong></p> <ul><li>在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息，比如说滚动位置。返回的对象将会作为componentDidUpdate函数中的snapShot函数</li></ul> <p><strong>componentDidMount</strong></p> <ul><li>DOM操作，如获取组件ref实例</li> <li>网络请求</li> <li>添加订阅（componentWillUnmount取消订阅）</li></ul> <p><strong>componentDidUpdate(preProps,preState,snapShot)</strong></p> <ul><li>组件更新后的DOM操作</li> <li>props变化后的网络请求</li></ul> <p><strong>componentWillUnmount</strong></p> <ul><li>清除定时器timer</li> <li>取消网络请求</li> <li>取消订阅</li></ul> <h2 id="react组件间通信"><a href="#react组件间通信" class="header-anchor">#</a> React组件间通信</h2> <ol><li><p><strong>父传子</strong></p> <p>props</p> <div class="language-react extra-class"><pre class="language-text"><code>// 父组件引用子组件
&lt;Child name=&quot;pjx&quot; age=&quot;20&quot;/&gt;
    
// 子组件
class Child extends Component{
    // 此处构造函数可以省略，因为和子类的默认构造函数一样（没有定义组件自己的state）
    constructor(props){
        super(props)
    }
    reder(){
        // es6对象解构
        const {name,age} = this.props
        return (
            &lt;h2&gt;{name + &quot; &quot; + age }&lt;/h2&gt;
        )
    }
}
</code></pre></div><p>使用<code>propTypes</code>验证props数据类型</p> <div class="language-react extra-class"><pre class="language-text"><code>import propTyeps form &quot;prop-types&quot;

Child.propTypes = {
    // 规定数据类型和必须值
    name:propTypes.string.isRequired,
    age:propTypes.number
}

// 使用子组件，number、array类型需要{}包裹
&lt;Child name=&quot;pjx&quot; age={20}/&gt;
</code></pre></div><p>设置props默认值</p> <div class="language-react extra-class"><pre class="language-text"><code>Child.defaultProps = {
    name:&quot;pjx&quot;,
    age:20
}
</code></pre></div></li> <li><p><strong>子传父</strong></p> <p>父组件props传递函数callback给子组件，子组件调用calbback</p> <p>注意：<strong>需要为子组件的调用的callback绑定父组件的作用域</strong></p> <ol><li><p>this.callback.bind(this)</p></li> <li><p>e =&gt; this.callback()，需要参数则 index =&gt; this.callback(index)</p></li> <li><p>callback定义为箭头函数 callback = () =&gt;{...}</p></li></ol></li></ol> <div class="language-react extra-class"><pre class="language-text"><code>// 父组件使用子组件，传递callback
&lt;Child callback = {e =&gt; this.callback()}/&gt;

// 子组件
class Child extends React.Cpmponent{
    render(){
        const {callback} = this.props
        return (
            &lt;h2&gt;{this.state.count}&lt;/h2&gt;
        	&lt;button onClick=callback&gt;+1&lt;/button&gt;
        )
    }
}

// 传递的props为函数
callback(){
    this.setState({
        count:this.state.count + 1
    })
}
</code></pre></div><ol start="3"><li><p><strong>跨层级组件通信</strong></p> <p>方法1：通过props一层层传递。便捷写法是 <code>{...props}</code></p> <p>方法2：Context上下文对象</p> <p>(<strong>class组件才有context对象,函数组件可以使用context.Consumer组件包裹使用共享数据</strong>）</p> <p>context相关api：</p> <ul><li><strong>React.createContext</strong> 创建一个context对象。context对象提供一个<strong>Provider</strong>组件，用于包裹顶层组件，向下层传递数据。如果有多个context向下传递共享数据，可以<strong>多层嵌套</strong>。</li> <li><strong>contextType</strong> 为组件指定向上层寻找数据的 context对象</li></ul> <p>类组件的context用法</p> <div class="language-react extra-class"><pre class="language-text"><code>// 创建context对象 , 并指定默认值
const UserContext = React.createContext({
    nickname:&quot;pjx&quot;,
    level:1
})

// 使用provider组件传递共享数据
class App extends Component{
    constructor(props){
        super(props)
        this.state = {
            nickname:&quot;pjx&quot;,
            level:99
        }
    }
    // 使用provider组件包裹，并通过value传值
    &lt;UserContext.Provider value={this.state}&gt;
    	&lt;Father/&gt;
    &lt;/UserContext.Provider/&gt;
}

// 使用contextType接受共享数据,并渲染数据
class Son extends Component{
    // 从context对象解构出共享数据
    const {nickname,level} = this.context
    render(){
        return (
        	&lt;div&gt;{nickname}&lt;/div&gt;
            &lt;div&gt;{level}&lt;/div&gt;
        )
    }
}
// 指定组件的contextType
Son.contextType = UserContext
</code></pre></div><p>函数组件的context用法 (类组件也可以使用consumer)</p> <div class="language-react extra-class"><pre class="language-text"><code>   function Son(){
	return (
		// 使用consumer消费组件包裹
		&lt;UserContext.Consumer&gt;
			{
				value =&gt; {
					return (
						&lt;div&gt;{value.nickname}&lt;/div&gt;
						&lt;div&gt;{value.level}&lt;/div&gt;
					)
				}
			}
		&lt;/UserContext.Consumer&gt;
	)
}
</code></pre></div></li> <li><p><strong>非嵌套组件</strong></p> <p>事件总线eventBus  react中使用<code>events</code>库</p> <div class="language-react extra-class"><pre class="language-text"><code>// 创建eventBus对象
const eventBus = new EventEmitter()
// 发射事件
event.emit(&quot;事件名&quot;,...args)
// 监听事件
componentDidMount(){
    eventBus.addListener(&quot;事件名&quot;,callback)
}
// 移除监听
componentWillUnmount(){
    eventBus.removeListener(&quot;事件名&quot;,callback)
}

</code></pre></div><p>redux</p></li></ol> <h2 id="react插槽的使用"><a href="#react插槽的使用" class="header-anchor">#</a> React插槽的使用</h2> <p>方法1：双标签组件嵌套子元素，通过props.children获取插槽（不推荐）</p> <p>​	      缺点是需要按顺序传递和获取插槽</p> <div class="language-react extra-class"><pre class="language-text"><code>// 定义
&lt;Navbar&gt;
	&lt;span&gt;aaa&lt;/span&gt;
	&lt;p&gt;bbb&lt;/p&gt;
	&lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;
&lt;/Navbar&gt;

// 使用
render(){
    const slot = this.porps.children
    return (
    	&lt;div className=&quot;left&quot;&gt;{slot[0]}&lt;/div&gt;
		&lt;div className=&quot;cenetr&quot;&gt;{slot[1]}&lt;/div&gt;
		&lt;div className=&quot;right&quot;&gt;{slot[2]}&lt;/div&gt;
    )
}
</code></pre></div><p>方法2：单标签组件传递props(推荐)</p> <div class="language-react extra-class"><pre class="language-text"><code>// 定义
&lt;Navbar left={&lt;span&gt;aaa&lt;/span&gt;} center={&lt;p&gt;bbb&lt;/p&gt;} right={&lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;}/&gt;
                                                           
// 使用
render(){
    const {left,center,right} = this.props
    return (
    	&lt;div className=&quot;left&quot;&gt;{left}&lt;/div&gt;
		&lt;div className=&quot;cenetr&quot;&gt;{center}&lt;/div&gt;
		&lt;div className=&quot;right&quot;&gt;{right}&lt;/div&gt;
    )
}                                                      
</code></pre></div><h2 id="setstate同步异步问题"><a href="#setstate同步异步问题" class="header-anchor">#</a> setState同步异步问题</h2> <p>https://juejin.im/post/6844903636749778958</p> <p><strong>结论</strong>：可能是同步的，也可能是异步的。<strong>合成事件</strong>和<strong>生命周期函数</strong>中是“异步”的，在<strong>原生事件</strong>和 <strong>setTimeout</strong>、<strong>Promise回调</strong>中都是同步的。</p> <p><strong>更新：</strong></p> <p><strong>react18版本之前setState可能同步也可能异步，react18版本更新后，setState默认都加入批处理，都是异步的</strong></p> <p>概念补充</p> <p><strong>合成事件</strong>：react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在<code>jsx</code>中常见的<code>onClick</code>、<code>onChange</code>这些都是合成事件</p> <p><strong>原生事件</strong>：是指非react合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件</p> <p><strong>setState设计为异步的原因：</strong></p> <ul><li><p><strong>提高性能</strong>。如果每调用一次setState就更新一次，那多次调用会多次触发render函数渲染界面，效率低。</p> <p>所以应该在获取到多个setState后进行一次合并，之后<strong>批量更新</strong></p></li> <li><p><strong>保证state和props同步</strong>。如果同步执行了setState改变了state，但是render函数还没有执行，则会导致state和props不同步。</p></li></ul> <p><strong>setState异步转同步</strong></p> <p><strong>react18前的版本：</strong></p> <ol><li>setTimeOut包裹setState</li></ol> <div class="language-react extra-class"><pre class="language-text"><code>setTimeOut(() =&gt; {
  this.setState({
      count:this.state.count+1
  })  
},0)
</code></pre></div><ol start="2"><li>原生dom事件监听中使用setState</li></ol> <p><strong>react18的版本：</strong></p> <p><strong>需要执行特殊的flushSync操作</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>flushSync(() =&gt; {
	this.setState({
      count:this.state.count+1
  })	
})
</code></pre></div><p><strong>总结</strong>：</p> <ol><li><p><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</p></li> <li><p><code>setState</code>的**“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”**，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p></li> <li><p><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</p></li></ol> <h2 id="获取setstate异步更新结果"><a href="#获取setstate异步更新结果" class="header-anchor">#</a> 获取setState异步更新结果</h2> <p>方法1：</p> <p>setState的第二个参数是一个回调函数。作用类似于vue中的<code>nextTick</code></p> <div class="language-react extra-class"><pre class="language-text"><code>this.setState({
    count:this.state.count+1
},() =&gt; {
    console.log(this.state.count)
})
</code></pre></div><p>方法2：</p> <p>componentDidUpdate生命周期函数</p> <h2 id="setstate的合并"><a href="#setstate的合并" class="header-anchor">#</a> setState的合并</h2> <p>合并包括数据合并和setState本身的合并</p> <ol><li><p>数据合并</p> <p><strong>当setState({obj})时，obj不会覆盖state，而是合并。</strong></p> <p>setState传入的是一个对象，底层是通过<code>Object.assign</code>方法将源对象的可枚举属性，复制到目标对象。并且源对象与目标对象如果有同名属性，则覆盖。没有，则新增。</p> <div class="language-react extra-class"><pre class="language-text"><code>const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target); // {a:1,b:4,c:5}
</code></pre></div></li> <li><p>setState本身合并</p> <p>多次执行setState，会出现只执行了最后一次的<strong>错觉</strong>，但是其实每一次都执行了。</p> <div class="language-react extra-class"><pre class="language-text"><code>// 结果是age从0到1
click=()=&gt;{
    console.log('start!')
        
        this.setState({name:'name1',age: this.state.age+1})

        this.setState({name:'name2',age: this.state.age+1})

        this.setState({name:'name3',age: this.state.age+1})

    console.log('end!')
};
</code></pre></div><p>原因：<strong>setState是异步更新的</strong>。每次setState都会执行，<strong>执行之后的值没有立马更新this.state，所以每次在setState里面取到的this.state的值都是最初的值</strong>，造成合并执行最后一条setState的错觉</p></li> <li><p>setState合并累加</p> <p>当setState<strong>传入函数</strong>，函数返回state，则多次setState可以实现多次累加</p> <div class="language-react extra-class"><pre class="language-text"><code>this.setState((preState,props) =&gt; {
	return {
        count:preState.count + 1
    }
})
this.setState((preState,props) =&gt; {
	return {
        count:preState.count + 1
    }
})
</code></pre></div></li></ol> <h2 id="setstate不可变性的力量"><a href="#setstate不可变性的力量" class="header-anchor">#</a> setState不可变性的力量</h2> <p>不可变性指的是在开发中需要<strong>避免直接修改state中的引用类型数据</strong>。否则SCU和PureComponent优化会失效。</p> <p><strong>原因</strong>：SCU和PureComponent的优化都是浅层比较，对于引用类型的数据而言，就是比较<strong>内存地址</strong>。</p> <p>当直接在原来的数据上修改时，内存地址未发生变化，所以浅层比较会返回false。</p> <div class="language-react extra-class"><pre class="language-text"><code>class App extends Component(){
    constructor(props){
        super(props){
            this.state = {
                // 引用类型数据
                frineds:[...]
            }
        }
    }
    
    ...
    btnClick(){
        // 错误做法 friends的内存地址未变化
        const newData = {&quot;name&quot;:&quot;pjx&quot;,age:20}
        this.state.frineds.push(newDate)
         this.setState({
        	friends:this.state.friends
         })
        
        // 推荐做法 赋值一份原数据
        const newFriends = [...this.state.friends]
        newFriends.push({&quot;name&quot;:&quot;pjx&quot;,age:20})
        this.setState({
            friends:newFriends
        })
    }
}
</code></pre></div><h2 id="scu、purecomponent、memo"><a href="#scu、purecomponent、memo" class="header-anchor">#</a> SCU、PureComponent、memo</h2> <p>shouldComponentUpdate生命周期函数用法</p> <div class="language-react extra-class"><pre class="language-text"><code>// 当jsx依赖的state变化，再执行render函数，否则阻断render
shouldComponentUpdate(nextProps,nextState,nextContext){
    if(this.state.count !== nextState.count){
        return true
    }
    return false
}
</code></pre></div><p>PureComponent用法（类组件）</p> <p>当多个组件中都需要实现SCU会很麻烦，可以让<strong>类组件继承自PureComponent</strong>，内部会自动实现SCU。</p> <p>底层通过<strong>shallowEqual</strong>浅层比较对象state和props，判断state和props是否改变</p> <div class="language-react extra-class"><pre class="language-text"><code>class App extends PureComponent{
    ...
}
</code></pre></div><p>memo（函数式组件）</p> <p>memo是<strong>高阶组件（HOC）</strong>，本质是一个函数，传入的参数是一个组件。</p> <p>底层实现也是<strong>shallowEqual</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>import {memo} from &quot;react&quot;

// memo包裹函数组件
const Header = memo(function Header(){
    ...
})
</code></pre></div><h2 id="高阶组件hoc"><a href="#高阶组件hoc" class="header-anchor">#</a> 高阶组件HOC</h2> <p><strong>高阶组件是参数为组件，返回值为新组件的函数</strong></p> <p>实际应用：<strong>memo</strong>、<strong>forwardRef</strong>、<strong>react-redux中的connect函数</strong>等都是高阶组件</p> <p>作用：</p> <ol><li>props增强(主题theme注入)</li> <li>jsx条件渲染（登录鉴权）</li> <li>劫持生命周期函数</li></ol> <p>缺点：</p> <ol><li>嵌套复杂</li> <li>不遵守规则的话，props可能被同名覆盖，数据不一致</li></ol> <h2 id="react严格模式"><a href="#react严格模式" class="header-anchor">#</a> React严格模式</h2> <p><strong>StrictMode 是一个用来突出显示应用程序中潜在问题的工具</strong></p> <ul><li>与Fragment 一样，StrictMode 不会渲染任何可见的 UI</li> <li>它为其后代元素触发额外的检查和警告</li> <li>严格模式检查仅在开发模式下运行，<em>它们不会影响生产构建</em></li></ul> <p><strong>严格检查检查的内容</strong></p> <ol><li><p>识别不安全的生命周期</p></li> <li><p>使用过时的ref API</p></li> <li><p>检查意外的副作用</p> <ul><li><strong>组件的constructor会被调用两次</strong></li> <li>这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用</li> <li>在生产环境中，是不会被调用两次的</li></ul></li> <li><p>使用废弃的findDOMNode方法</p> <ul><li>在之前的React API中，可以通过findDOMNode来获取DOM，已不推荐使用</li></ul></li> <li><p>检测过时的context API</p> <ul><li>早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的，已不推荐使用</li></ul></li></ol> <h2 id="redux及中间件"><a href="#redux及中间件" class="header-anchor">#</a> Redux及中间件</h2> <p>在函数式编程中一个重要的概念叫做<code>纯函数</code>，redux中的<strong>reducer</strong>函数就是一个纯函数。</p> <p><strong>纯函数</strong>特点：</p> <ol><li>确定的输入，一定产生确定的输出</li> <li>函数执行中不会产生副作用（如触发事件、DOM更新）</li></ol> <p><strong>Redux三大核心概念</strong></p> <ul><li><p>Store</p> <p>就是defaultState</p> <div class="language-react extra-class"><pre class="language-text"><code>// immutable.js中的Map函数
const defaultState = Map({
	playList: [],
	currentSong: {},
  currentSongIndex: 0,
  /**
   * 播放模式
   * 0 顺序
   * 1 随机
   * 2 单曲循环
   */
  playMode:0, 
  lyric:[],
  currentLyricIndex:0
});
</code></pre></div></li> <li><p>Action</p> <p>redux中的所有数据变化，必须通过派发（dispatch）action来更新。</p> <p>action是一个<strong>JS对象</strong>，对象中包含type和content。</p> <p>通过dispatch action更新数据的好处是可以通过redux开发者工具跟踪数据变化。</p> <div class="language-react extra-class"><pre class="language-text"><code>// 改变歌曲列表
const changePlayListAction = (playList) =&gt; ({
	type: actionTypes.CHANGE_PLAY_LIST,
	playList,
});

...

dispatch(changePlayListAction(newList));
</code></pre></div></li> <li><p>Reducer</p> <p>reducer是一个纯函数，可以将state和action联系在一起。reducer将传入的state和action经过纯函数处理，生成新的state。</p> <p><strong>每次调用dispatch都会触发reducer函数执行</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>const defaultState = Map({
	playList: [],
	currentSong: {},
  currentSongIndex: 0,
  /**
   * 播放模式
   * 0 顺序
   * 1 随机
   * 2 单曲循环
   */
  playMode:0, 
  lyric:[],
  currentLyricIndex:0
});

function reducer(state = defaultState,action){
  switch (action.type){
    case actionTypes.CHANGE_CURRENT_SONG:
      return state.set(&quot;currentSong&quot;, action.currentSong);
    case actionTypes.CHANGE_PLAY_LIST:
      return state.set(&quot;playList&quot;,action.playList)
    case actionTypes.CHANGE_CURRENT_SONG_INDEX:
      return state.set(&quot;currentSongIndex&quot;, action.currentSongIndex);
    case actionTypes.CHANGE_PLAY_MODE:
      return state.set(&quot;playMode&quot;,action.playMode)
    case actionTypes.CHANGE_LYRIC:
      return state.set(&quot;lyric&quot;,action.lyric)
    case actionTypes.CHANGE_CURRENT_LYRIC_INDEX:
      return state.set(&quot;currentLyricIndex&quot;, action.currentLyricIndex);
    default:
      return state;
  }
}

export default reducer;
</code></pre></div><p><strong>reducer分模块与合并</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>import { combineReducers } from &quot;redux-immutable&quot;;

// 导入各个模块的reducer
import recommendReducer from &quot;@/pages/discover/children/recommend/store&quot;;
import playerReducer from &quot;@/pages/player/store&quot;

// 将各个模块的reducer合并,导出store.state
// 使用redux-immutable的combineReducers
const cReducers = combineReducers({
	recommend:recommendReducer,
	player:playerReducer
});

export default cReducers;
</code></pre></div><p>combineReducers函数：</p> <ol><li>事实上，它也是将我们传入的reducers<strong>合并到一个对象中</strong>，最终返回一个combination的<strong>函数</strong>（相当于我们之前的reducer函</li></ol> <p>数了）；</p> <ol start="2"><li><p>在执行combination函数的过程中，它会通过判断<strong>前后返回的数据是否相同</strong>来决定返回之前的state还是新的state；</p></li> <li><p>新的state会<strong>触发订阅者</strong>发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新</p></li></ol> <h3 id="react中间件redux-thunk"><a href="#react中间件redux-thunk" class="header-anchor">#</a> React中间件redux-thunk</h3> <p><strong>redux中异步操作--使用redux-thunk中间件</strong></p> <p><strong>注意：<strong>默认情况下redux中只能dispatch一个</strong>action对象</strong>（type和content），但是redux-thunk可以让dispatch一个<strong>action函数</strong>，函数会被调用，并且传递给这个函数两个参数：<strong>dispatch函数和getState函数</strong>。</p> <p>中间件的目的是在dispatch和action到达reducer之间，扩展自己的代码，比如网络请求。</p> <p>参数的dispatch函数可以用于再次派发dispatch action，getState函数可以用于获取原来的state。</p> <p>基本使用</p> <div class="language-react extra-class"><pre class="language-text"><code>// 启用redux-thunk中间件和redux开发者工具

import { createStore, compose, applyMiddleware } from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import reducer from &quot;./reducer&quot;;

// 开启浏览器redux调试工具
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

// 使用thunk中间件
const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));

export default store;
</code></pre></div><p>eg：</p> <div class="language-react extra-class"><pre class="language-text"><code>// id获取歌词

// dispatch的是一个函数，thunk中间件传递了dispatch函数作为参数
export const getLyricAction = (id) =&gt; {
	return (dispatch) =&gt; {
		getLyric(id).then((res) =&gt; {
			const lyricString = res.lrc.lyric;
			const lyric = parseLyric(lyricString);
			dispatch(changeLyricAction(lyric));
		});
	};
};
</code></pre></div><p><strong>基本实现原理</strong>：</p> <p>当你使用 <code>redux-thunk</code> 中间件时，它会在 Redux 的 action 被 dispatch 到 reducer 之前<strong>拦截 action</strong>。如果 action 是一个函数（即 thunk），<code>redux-thunk</code> 会执行这个函数，并将 <code>dispatch</code> 和 <code>getState</code> 作为参数传递给它</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchThunk</span><span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> store<span class="token punctuation">.</span>dispach<span class="token punctuation">;</span>
    
    <span class="token keyword">function</span> <span class="token function">dispatchAndThunk</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">action</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">,</span>store<span class="token punctuation">.</span>getState<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">next</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    store<span class="token punctuation">.</span>dispatch <span class="token operator">=</span> dispatchAndThunk<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Redux使用流程</strong></p> <img src="https://gitee.com/coderPjx/images/raw/master/images/Snipaste_2021-04-27_17-04-45.jpg" style="zoom:80%;"></li></ul> <h2 id="封装react-redux的connect函数"><a href="#封装react-redux的connect函数" class="header-anchor">#</a> 封装react-redux的connect函数</h2> <p>connect函数的<strong>返回值</strong> 本质是 <strong>高阶组件（HOC）</strong></p> <p>通过监听store变化，将redux和组件联系起来，减少组件中的重复逻辑</p> <p>由于使用麻烦，react-readux推出<code>useDispatch</code>和<code>useSelector</code>等hooks</p> <div class="language-react extra-class"><pre class="language-text"><code>import { PureComponent } form 'react'
import store from '../store'

// 定义connect函数
function connect(mapStateToProps,mapDispatchToProps){
    return function(WrapperComponent){
        class NewComponent extends PureComponent(){
            constructor(props){
                super(props)
                this.state = {
                    storeState:mapStateToProps(store.getState())
                }
            }
            componentDidMount(){
                // 订阅store监听数据改变，修改state重新渲染
                this.unsubscribe = store.subscribe(() =&gt; {
                    this.setState = ({
                        storeState :mapStateToProps(store.getState())
                    })
                })
            }
            componentWillUnmount(){
                // 取消订阅store
                this.unsubscribe()
            }
            render(){
                const stateObj = this.mapStateToProps(store.getState())
                const dispatchObj = this.mapDispatchToProps(store.dispatch)
                return &lt;WrapperComponent {...this.props} {...stateObj} {...dispatchObj}/&gt;
            }
        return NewComponent
        }
    }
    
}
</code></pre></div><p>使用</p> <div class="language-react extra-class"><pre class="language-text"><code>// 定义基础组件
class Home extends PureComponent{
    render(){
        return (
        	&lt;div&gt;
            	&lt;h1&gt;Home&lt;/h1&gt;
            	&lt;button onClick={e =&gt; this.props.increment()}&gt;+1&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}

// 定义mapStateToPorps和mapDispatchToProps 函数

// state参数是store.getState()
const mapStateToPorps = state =&gt; ({
    count:state.count
})
// dispatch参数是store.dispatch
const mapDispatchToProps = dispatch =&gt; ({
    increment(){
        dispatch(increment())
    }
})
	
// 真正使用的是经过处理的Home组件
export default connect(mapStateToPorps,mapDispatchToProps)(Home)

</code></pre></div><h2 id="前端路由的原理"><a href="#前端路由的原理" class="header-anchor">#</a> 前端路由的原理</h2> <p>前端路由可以实现url改变，页面不刷新，但是切换页面显示的内容。</p> <p>实现页面不刷新，url改变有hash和history两种方法。</p> <ul><li><p>hash模式</p> <p>通过<code>addEventListener</code>和<code>hashchange</code>事件，对<code>location.hash</code>进行监听，对不同的hash值做不同的页面渲染</p></li> <li><p>history模式</p> <p>通过html5的新api，pushState，popstate，replaceState，go，forward，back等，通过<code>addEventListener</code>和<code>popstate</code>事件，监听<code>location.pathname</code>，对不同的pathname进行不同的页面渲染</p></li></ul> <h2 id="useeffect模拟生命周期函数"><a href="#useeffect模拟生命周期函数" class="header-anchor">#</a> useEffect模拟生命周期函数</h2> <p>常用于组件内的effect（具有副作用）事件。例如网络请求、事件订阅和取消。</p> <p>参数1：回调函数。回调函数中可以模拟事件订阅（<strong>componentDidMount</strong>），回调函数返回值可以为一个函数，用于<strong>清除effect</strong>，取消事件订阅(<strong>componentWillUnmount</strong>)</p> <p>参数2：依赖项数组。页面的渲染依赖这个数据项，当依赖项数组的数据发生变化，才执行回调函数并重新渲染。（<strong>componentShoudUpdate</strong>）</p> <p><strong>注意：</strong></p> <ol><li><p>默认情况下，如果不传递第二个参数（undefined），useEffect的回调函数会在<strong>每次渲染时都重新执行</strong></p></li> <li><p>但是，如果一个函数我们不希望依赖任何的内容时，也可以传入一个<strong>空的数组 []</strong></p> <p>此时两个回调函数（传入的回调函数和返回的函数）分别对应的就是<strong>componentDidMount</strong>和<strong>componentWillUnmount</strong>生命周期函数</p></li></ol> <div class="language-react extra-class"><pre class="language-text"><code>useEffect = (() =&gt; {
    ...
    console.log(&quot;订阅事件&quot;)
    
    return () =&gt; {
        ...
        console.log(&quot;取消订阅事件&quot;)
    }
},[dependency])
</code></pre></div><h2 id="usememo和usecallback的区别"><a href="#usememo和usecallback的区别" class="header-anchor">#</a> useMemo和useCallback的区别</h2> <p>两个hook函数的作用都是<strong>性能优化</strong>，useCallback是对函数做优化，useMemo是对返回结果做优化</p> <p><strong>useMemo</strong></p> <p>使用场景：</p> <ol><li>复杂计算缓存</li> <li>父组件传递子组件<strong>引用类型值</strong>缓存</li></ol> <p>用于<strong>缓存返回值</strong>，第一个参数为要缓存的函数（注意实际被缓存的是函数被执行过后的值），第二个参数为依赖项数组，如果依赖发生了变化，那么就会重新执行这个函数，得到新的返回值；否则当组件重新渲染时，不会重新执行这个函数，而是直接取被缓存的该函数的返回值。</p> <p>复杂计算缓存</p> <div class="language-react extra-class"><pre class="language-text"><code>// 求和函数
function sum(count){
  console.log(&quot;重新计算&quot;)
  let total = 0;
  for(let i = 1;i &lt;= count ;i++) {
    total += i;
  }
  return total;
}
export default function App() {
  console.log(&quot;App渲染&quot;)
  const [count, setcount] = useState(0)
  const [show, setshow] = useState(true)

  // 当count变化时，才重新执行求和函数。
  const total = useMemo(() =&gt; {
    return sum(count)
  },[count])

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数：{total}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setcount(count + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={e =&gt; setshow(!show)}&gt;切换&lt;/button&gt;
    &lt;/div&gt;
  )
</code></pre></div><p>引用值传递缓存</p> <div class="language-react extra-class"><pre class="language-text"><code>const MyInfo = memo((props) =&gt; {
	console.log(&quot;MyInfo组件重新渲染&quot;);
	return (
		&lt;h2&gt;
			姓名：{props.info.name} 年龄：{props.info.age}
		&lt;/h2&gt;
	);
});

export default function App() {
	console.log(&quot;App重新渲染&quot;);
	const [show, setshow] = useState(true);

    // 缓存引用值
	const info = useMemo(() =&gt; {
		return { name: &quot;pjx&quot;, age: 20 };
	}, []);

	return (
		&lt;div&gt;
			&lt;MyInfo info={info} /&gt;
			&lt;button onClick={(e) =&gt; setshow(!show)}&gt;切换&lt;/button&gt;
		&lt;/div&gt;
	);
</code></pre></div><p><strong>useCallback</strong></p> <p><strong>使用场景：在将组件中的一个函数，传递给子组件进行回调使用时，使用useCallback进行优化</strong></p> <p>用于<strong>缓存函数</strong>，第一个参数为要缓存的函数，第二个参数为依赖项数组，如果依赖发生了变化，那么就会生成一个新的函数；否则当组件重新渲染时，不会重新定义这个函数，而是会取缓存。</p> <p><strong>使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>// 自定义MyButton组件
const MyButton = memo((props) =&gt; {
	console.log(&quot;MyButton&quot; + props.title + &quot;子组件渲染&quot;);
	return &lt;button onClick={props.increment}&gt;MyButton +1&lt;/button&gt;;
});

/**
 * 当点击切换改变show,子组件会跟随父组件会重新渲染。
 */
export default function App() {
	console.log(&quot;App父组件渲染&quot;);
	const [count, setcount] = useState(0);
	const [show, setshow] = useState(true);

	/**
	 * 按钮1 未使用useCallBack 不会进行性能优化。
   * 当父子间state改变，子组件没改变，会进行不必要的重新渲染，浪费性能。
	 */

	const increment1 = () =&gt; {
		console.log(&quot;按钮1点击&quot;);
		setcount(count + 1);
  };
  
  /**
   * 按钮2 使用useCallBack 会进行性能优化。
   * 当父组件state改变，子组件没改变，不会进行不必要的重新渲染。
   */
	const increment2 = useCallback(() =&gt; {
		console.log(&quot;按钮2点击&quot;);
		setcount(count + 1);
	}, [count]);
	return (
		&lt;div&gt;
			&lt;h2&gt;当前计数：{count}&lt;/h2&gt;
			&lt;MyButton title={1} increment={increment1} /&gt;
			&lt;MyButton title={2} increment={increment2} /&gt;
			&lt;button onClick={(e) =&gt; setshow(!show)}&gt;切换&lt;/button&gt;
		&lt;/div&gt;
	);
</code></pre></div><p><strong>注意</strong>：以下写法useCallback和useMemo作用一样</p> <div class="language-react extra-class"><pre class="language-text"><code>useCallback(fn,[])
useMemo(() =&gt; fn,[])
</code></pre></div><h2 id="usestate和usereducer的区别"><a href="#usestate和usereducer的区别" class="header-anchor">#</a> useState和useReducer的区别</h2> <p>useState用于组件内部的简易state。</p> <p>useReducer和redux中的reducer无关。useRuducer用于组件内的复杂state。</p> <h2 id="useeffect和uselayouteffect的区别"><a href="#useeffect和uselayouteffect的区别" class="header-anchor">#</a> useEffect和useLayoutEffect的区别</h2> <p>useEffect在<strong>DOM更新之后执行，不会阻塞DOM的更新</strong>。</p> <p>useLayoutEffect在<strong>DOM更新之前执行，会阻塞DOM的更新</strong>。</p> <p>如果希望某事件发生后，再更新DOM，需要使用useLayoutEffect</p> <h2 id="useimperativehandle"><a href="#useimperativehandle" class="header-anchor">#</a> <strong>useImperativeHandle</strong></h2> <p>父组件通过forwardRef可以将ref转发到子组件，子组件拿到父组件中创建的ref，绑定到自己的某一个元素中。</p> <p>这样就实现了<strong>ref的转发</strong>，父组件可以通过ref直接调用子组件的方法。</p> <p><strong>forwardRef的做法本身没有什么问题，但是我们是将子组件的DOM直接暴露给了父组件存在问题</strong></p> <ul><li><p>直接暴露给父组件带来的问题是某些情况的<strong>不可控</strong></p></li> <li><p>父组件可以拿到DOM后进行任意的操作</p></li></ul> <p>例如我们只是希望父组件可以操作子组件input的focus，其他并不希望它随意操作</p> <p><strong>通过useImperativeHandle可以只暴露固定的操作</strong></p> <p>通过useImperativeHandle的Hook，将传入的ref和useImperativeHandle<strong>第二个参数返回的对象绑定到了一起</strong>，所以在父组件中，使用 inputRef.current时，实际上使用的是返回第二个参数的对象</p> <p>比如我调用了 focus函数，甚至可以调用 printHello函数</p> <div class="language-react extra-class"><pre class="language-text"><code>const MyInput = forwardRef(function(props,ref) {
    const inputRef = useRef();
    // 第二个参数返回的对象就是父组件可以进行调用的操作
    useImperativeHandle(ref,() =&gt; {
        focus() {
            inputRef.current.focus();
        }
		printHello() {
            console.log('Hello')
        }
    })
    
    return &lt;input ref={inptRef} type=&quot;text&quot; /&gt;
})
</code></pre></div><h2 id="usedispatch、useselector、shallowequal"><a href="#usedispatch、useselector、shallowequal" class="header-anchor">#</a> useDispatch、useSelector、shallowEqual</h2> <p><strong>在Redux7.1开始，提供了Hook的方式，我们再也不需要编写connect以及对应的映射函数</strong></p> <p>useDispatch直接返回dispatch函数实例。</p> <p>useSelector返回state中的对象。</p> <p>参数1：返回state对象的函数</p> <p>参数2：是否进行浅层比较<code>shallowEqual</code></p> <p><strong>注意</strong>：当使用useSelector时，可以通过传入第二个参数shallowEqual进行性能优化。</p> <p><strong>useSelector默认的比较是<code>===</code>比较，所以当state变化，无论页面是否使用（依赖）state，总是会重新渲染。</strong></p> <div class="language-react extra-class"><pre class="language-text"><code>const dispatch = useDispatch()
const { topBanners } = useSelector(state =&gt; ({
    topBanners: state.recommend.topBanners
}),shallowEqual) 

useEffect(() =&gt; {
    dispatch(getTopBannersAction())
},[dispatch])
</code></pre></div><h2 id="redux-toolkit"><a href="#redux-toolkit" class="header-anchor">#</a> redux-toolkit</h2> <p>优点：</p> <ol><li><p><strong>简化的语法</strong>：提供了<code>createSlice</code>和<code>createReducer</code>等工具函数，内部会<strong>自动生成对应的reducer和action</strong>，减少了编写Redux reducer和action creator时的样板代码量，使代码更加简洁和易于理解</p></li> <li><p><strong>内置Immerjs支持</strong>：集成了Immerjs库，简化了在reducer中进行状态更新的过程。开发者可以直接修改状态（修改state）而无需手动编写<strong>不可变性</strong>逻辑（<strong>无需浅拷贝</strong>），从而减少了出错的可能性并提高了代码的可读性</p> <p>了解immerjs：https://mp.weixin.qq.com/s/hfeCDCcodBCGS5GpedxCGg</p></li> <li><p><strong>默认集成Redux Thunk</strong>：自带了<strong>Redux Thunk</strong>中间件，<strong>createAsyncThunk</strong>允许开发者编写简单直观的异步逻辑，无需额外安装或配置中间件</p></li> <li><p><strong>创建标准化的redux store</strong>：通过<code>configureStore</code>函数可以轻松地创建一个包含预定义中间件和增强器的Redux store，并且还能够自动进行性能优化。</p></li> <li><p><strong>更好的性能</strong>：Redux Toolkit内部对性能进行了优化，使用了memoization技术来提高重渲染的效率。这意味着在某些情况下，Redux Toolkit可能比传统的React-Redux具有更好的性能表现。</p></li> <li><p><strong>官方推荐</strong>：Redux Toolkit是由Redux官方团队推出的工具包，因此可以获得更好的支持和文档，以及与Redux生态系统的更好集成</p></li></ol> <p><strong>Redux Toolkit的核心API</strong></p> <ul><li>configureStore：包装createStore以提供简化的配置选项和良好的默认值。它可以自动组合你的 slice reducer，添加你提供</li></ul> <p>​	的任何 Redux 中间件，<strong>redux-thunk</strong>默认包含，并启用 Redux DevTools Extension。</p> <ul><li><p>createSlice：接受reducer函数的对象、切片名称和初始状态值，<strong>返回值中包含自动生成切片reducer和相应的actions</strong>。</p></li> <li><p>createAsyncThunk: 接受一个动作类型字符串和一个返回<strong>Promise</strong>的函数，并生成一个<strong>pending/fulfilled/rejected</strong>基于该Promise分</p></li></ul> <p>​	派动作类型的 thunk</p> <p><strong>createSlice</strong>使用</p> <p>createSlice返回值为对象，包含自动生成的所有的actions和reducer</p> <p>主要参数：</p> <ul><li>name：用户标记slice的名词</li></ul> <p>​	在之后的redux-devtool中会显示对应的名词；</p> <ul><li>initialState：初始化值</li></ul> <p>​	第一次初始化时的值；</p> <ul><li>reducers：相当于redux的<strong>reducer函数</strong></li> <li>对象类型，并且可以添加很多的函数；</li> <li><strong>每一个函数类似于redux的reducer函数中的一个case语句</strong>；</li> <li>函数的参数：state和调用这个action时，传递的action参数</li> <li>extraReducers：监听异步Promise的状态<strong>pending/fulfilled/rejected</strong>，进行对应的操作</li></ul> <p><strong>createAsyncThunk</strong>使用</p> <p>主要参数：</p> <ul><li>name：用于标记thunk的名词</li> <li>异步函数：参数包括额外自定义的参数和dispatch、getState</li></ul> <p>异步操作的结果处理：</p> <ul><li>方式1：extraReducers监听Promise状态</li> <li>方式2：异步函数中传递了dispatch、getState，异步请求返回结果后直接处理</li></ul> <p><strong>RTK基本使用</strong></p> <p>1.安装 @reduxjs/toolkit 和 react-redux</p> <p>store/index.js 定义store</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> configureStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;@reduxjs/toolkit&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">configureStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">reducer</span><span class="token operator">:</span><span class="token punctuation">{</span>
        xxx：xxx
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> store
</code></pre></div><p>2.index.js 入口文件中引入store ，并通过Provider组件传入store</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Provider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span>
<span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span>

<span class="token operator">...</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Provider</span></span> <span class="token attr-name">store</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>store<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    ...
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Provider</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>3.分模块定义reducer</p> <p>home.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createSlice <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@reduxjs/toolkit'</span>

<span class="token comment">// createAsyncThunk异步操作</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> fetchHomeDataAction <span class="token operator">=</span> <span class="token function">createAsyncThunk</span><span class="token punctuation">(</span>
  <span class="token string">&quot;fetchGoodPrice&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getHomeGoodPriceData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> homeSlice <span class="token operator">=</span> <span class="token function">createSlice</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">initialState</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span><span class="token number">1</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">reducers</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">// 每一个函数类似于redux的reducer函数中的一个case语句</span>
        <span class="token comment">// RTK内部会自动生成对应的actions</span>
        <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span><span class="token punctuation">{</span>payload<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 经过RTK优化（Immer库）可以直接在state上做修改，不需要做浅拷贝</span>
            state<span class="token punctuation">.</span>count <span class="token operator">+=</span> payload<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span><span class="token punctuation">{</span>payload<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            state<span class="token punctuation">.</span>count <span class="token operator">-=</span> payload<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 以在createSlice的entraReducer中监听异步操作结果</span>
    <span class="token function-variable function">extraReducers</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">builder</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    builder
      <span class="token punctuation">.</span><span class="token function">addCase</span><span class="token punctuation">(</span>fetchHomeDataAction<span class="token punctuation">.</span>pending<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">addCase</span><span class="token punctuation">(</span>fetchHomeDataAction<span class="token punctuation">.</span>fulfilled<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> <span class="token punctuation">{</span> payload <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>goodPriceInfo <span class="token operator">=</span> payload<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">addCase</span><span class="token punctuation">(</span>fetchHomeDataAction<span class="token punctuation">.</span>rejected<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> <span class="token punctuation">{</span> error <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        state<span class="token punctuation">.</span>error <span class="token operator">=</span> error<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// createSlice返回值中包含自动生成切片reducer和相应的actions</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token operator">=</span> homeSlice<span class="token punctuation">.</span>actions
<span class="token keyword">export</span> <span class="token keyword">default</span> homeSlice<span class="token punctuation">.</span>reducer
</code></pre></div><p>4.在store/index.js中引用定义的reducer模块</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> homeReducer <span class="token keyword">from</span> <span class="token string">'./modules/home'</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">configureStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">reducer</span><span class="token operator">:</span><span class="token punctuation">{</span>
        home：homeReducer
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5ab2ec69.js" defer></script><script src="/assets/js/2.eeb24f79.js" defer></script><script src="/assets/js/16.551a14fc.js" defer></script>
  </body>
</html>
