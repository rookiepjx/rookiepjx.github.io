<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>OSI七层模型和TCP/IP五层模型 | Ronan&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/avatar.jpg">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.7b36eabc.css" as="style"><link rel="preload" href="/assets/js/app.5ab2ec69.js" as="script"><link rel="preload" href="/assets/js/2.eeb24f79.js" as="script"><link rel="preload" href="/assets/js/10.d0415309.js" as="script"><link rel="prefetch" href="/assets/js/11.11f96ddc.js"><link rel="prefetch" href="/assets/js/12.17cdedb4.js"><link rel="prefetch" href="/assets/js/13.b53a64a6.js"><link rel="prefetch" href="/assets/js/14.6127168f.js"><link rel="prefetch" href="/assets/js/15.c6fec423.js"><link rel="prefetch" href="/assets/js/16.551a14fc.js"><link rel="prefetch" href="/assets/js/17.3ad529cc.js"><link rel="prefetch" href="/assets/js/18.9da1d026.js"><link rel="prefetch" href="/assets/js/19.0ff8f3e6.js"><link rel="prefetch" href="/assets/js/3.1801cb39.js"><link rel="prefetch" href="/assets/js/4.30c96a68.js"><link rel="prefetch" href="/assets/js/5.f0e2ef51.js"><link rel="prefetch" href="/assets/js/6.e86df8f9.js"><link rel="prefetch" href="/assets/js/7.e76e2440.js"><link rel="prefetch" href="/assets/js/8.8df23d51.js"><link rel="prefetch" href="/assets/js/9.8c479be0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7b36eabc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="Ronan's Blog" class="logo"> <span class="site-name can-hide">Ronan's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Css/" class="nav-link">
  Css
</a></div><div class="nav-item"><a href="/Js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/Js+/" class="nav-link">
  Js高级
</a></div><div class="nav-item"><a href="/Ts/" class="nav-link">
  Ts
</a></div><div class="nav-item"><a href="/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Network/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Network
</a></div><div class="nav-item"><a href="/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Others/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Others/Nginx/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/Others/Algorithm/" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/Others/粤语/" class="nav-link">
  粤语
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/Css/" class="nav-link">
  Css
</a></div><div class="nav-item"><a href="/Js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/Js+/" class="nav-link">
  Js高级
</a></div><div class="nav-item"><a href="/Ts/" class="nav-link">
  Ts
</a></div><div class="nav-item"><a href="/Vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/React/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/Network/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Network
</a></div><div class="nav-item"><a href="/Webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Others/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Others/Nginx/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/Others/Algorithm/" class="nav-link">
  算法
</a></li><li class="dropdown-item"><!----> <a href="/Others/粤语/" class="nav-link">
  粤语
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>OSI七层模型和TCP/IP五层模型</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Network/#osi七层模型和tcp-ip五层模型" class="sidebar-link">OSI七层模型和TCP/IP五层模型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#http1-0、1-1、2-0" class="sidebar-link">Http1.0、1.1、2.0</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#http和https" class="sidebar-link">Http和Https</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#websocket" class="sidebar-link">WebSocket</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#tcp三次握手四次挥手" class="sidebar-link">TCP三次握手四次挥手</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#tcp和udp" class="sidebar-link">TCP和UDP</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#tcp的可靠交付" class="sidebar-link">TCP的可靠交付</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#tcp的流量控制" class="sidebar-link">TCP的流量控制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#tcp的拥塞控制" class="sidebar-link">TCP的拥塞控制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#http状态码" class="sidebar-link">http状态码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#浏览器存储" class="sidebar-link">浏览器存储</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#get和post" class="sidebar-link">Get和Post</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#在地址栏输入url回车后-都发生了什么" class="sidebar-link">在地址栏输入URL回车后，都发生了什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#csrf和xss网络攻击和防范" class="sidebar-link">CSRF和XSS网络攻击和防范</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Network/#浏览器缓存机制" class="sidebar-link">浏览器缓存机制</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="osi七层模型和tcp-ip五层模型"><a href="#osi七层模型和tcp-ip五层模型" class="header-anchor">#</a> OSI七层模型和TCP/IP五层模型</h2> <p>OSI模型</p> <table><thead><tr><th style="text-align:center;">层级</th> <th style="text-align:center;">功能</th> <th style="text-align:center;">常用协议</th></tr></thead> <tbody><tr><td style="text-align:center;">应用层</td> <td style="text-align:center;">信息语法语义，数据加密，格式转换，压缩解压</td> <td style="text-align:center;">HTTP,HTTPS,FTP,SMTP,POP3,DNS,TELNET,SSH...</td></tr> <tr><td style="text-align:center;">表示层</td> <td style="text-align:center;">各种应用程序协议，如文件传输，电子邮件，文件服务，虚拟终端</td> <td style="text-align:center;">JPEG,ASCII</td></tr> <tr><td style="text-align:center;">会话层</td> <td style="text-align:center;">不同机器间的用户建立和管理会话</td> <td style="text-align:center;">SSL,TLS</td></tr> <tr><td style="text-align:center;">传输层</td> <td style="text-align:center;">提供端对端的数据传输接口</td> <td style="text-align:center;">TCP,UDP</td></tr> <tr><td style="text-align:center;">网络层</td> <td style="text-align:center;">控制子网运行，如逻辑编址，分组传输，路由选择</td> <td style="text-align:center;">IP,RIP,BGP,ICMP</td></tr> <tr><td style="text-align:center;">链路层</td> <td style="text-align:center;">物理寻址，传输带有地址的帧</td> <td style="text-align:center;">MAC,ARP,RARP</td></tr> <tr><td style="text-align:center;">物理层</td> <td style="text-align:center;">以二进制数据形式在物理媒体上传输数据</td> <td style="text-align:center;">IEEE802,ISO</td></tr></tbody></table> <p>TCP/IP模型</p> <table><thead><tr><th style="text-align:center;">层级</th> <th style="text-align:center;">网络设备</th></tr></thead> <tbody><tr><td style="text-align:center;">应用层</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">传输层</td> <td style="text-align:center;">网关</td></tr> <tr><td style="text-align:center;">网络层</td> <td style="text-align:center;">路由器</td></tr> <tr><td style="text-align:center;">链路层</td> <td style="text-align:center;">网桥，交换机</td></tr> <tr><td style="text-align:center;">物理层</td> <td style="text-align:center;">网卡，网线，集线器，中继器，调制解调器</td></tr></tbody></table> <h2 id="http1-0、1-1、2-0"><a href="#http1-0、1-1、2-0" class="header-anchor">#</a> Http1.0、1.1、2.0</h2> <p>1.0和1.1</p> <table><thead><tr><th></th> <th>1.0</th> <th>1.1</th></tr></thead> <tbody><tr><td>连接类型</td> <td>短连接</td> <td>长连接</td></tr> <tr><td>缓存响应头</td> <td>expire、If-Modified-Since</td> <td>cache-control、Last-Modified、ETag、If-Unmodified-Since, If-Match, If-None-Match</td></tr> <tr><td>请求方法</td> <td>get、post</td> <td>新增put、delete、head、options、trace、connect</td></tr> <tr><td>带宽优化</td> <td>只能返回整个对象、不支持断点续传</td> <td>range请求头可以返回部分对象、支持断点续传</td></tr> <tr><td>错误通知管理</td> <td></td> <td>新增24个错误状态响应码</td></tr> <tr><td>host头处理</td> <td>url不传递主机名</td> <td>支持host头</td></tr></tbody></table> <p>1.1和2.0</p> <table><thead><tr><th></th> <th>1.1</th> <th>2.0</th></tr></thead> <tbody><tr><td>二进制传输</td> <td>否，文本传输</td> <td>是</td></tr> <tr><td>多路复用</td> <td>否</td> <td>是</td></tr> <tr><td>头部压缩</td> <td>否</td> <td>是</td></tr> <tr><td>服务端推送</td> <td>不支持</td> <td>支持</td></tr></tbody></table> <h2 id="http和https"><a href="#http和https" class="header-anchor">#</a> Http和Https</h2> <blockquote><p><strong>基本概念</strong></p></blockquote> <p><strong>http</strong></p> <p>(HyperText Transfer Protocol，超文本传输协议）互联网上应用最广泛的网络传输协议。</p> <p><strong>https</strong></p> <p>http的安全版本，加入了ssl(secure socket lay,安全套接层)。作用是建立一个安全的信息传输通道，保证数据传输的安全，确保网站的真实性。</p> <blockquote><p><strong>区别</strong></p></blockquote> <table><thead><tr><th></th> <th>http</th> <th>https</th></tr></thead> <tbody><tr><td>安全性</td> <td>明文传输，未加密</td> <td>ssl加密传输</td></tr> <tr><td>端口号</td> <td>80</td> <td>443</td></tr> <tr><td>复杂度</td> <td>无状态连接;简单</td> <td>加密传输;身份认证;复杂</td></tr> <tr><td>优点</td> <td>连接简单;速度快</td> <td>安全</td></tr> <tr><td>缺点</td> <td>不安全</td> <td>CA证书费用高;连接速度慢费时;增加数据开销</td></tr></tbody></table> <blockquote><p><strong>https工作原理</strong></p></blockquote> <ol><li>首先客户端通过https的URL访问服务器建立SSL连接。</li> <li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li> <li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li> <li>客户端的浏览器根据双方同意的安全等级，<strong>建立会话密钥，然后利用网站的公钥将会话密钥加密</strong>，并传送给网站。</li> <li>服务器利用自己的<strong>私钥解密出会话密钥</strong>。</li> <li>服务器<strong>利用会话密钥加密与客户端之间的通信</strong>。</li></ol> <h2 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h2> <p><img src="https://gitee.com/coderPjx/images/raw/master/images/Snipaste_2020-12-28_15-42-04.jpg" alt=""></p> <ul><li>基本概念</li></ul> <p>webSocket是一个基于TCP实现的<strong>全双工</strong>网络协议。在前端中<strong>HTML5</strong>已经实现了。</p> <p>其最大的特点就是<strong>全双工</strong>：服务器可以主动向客户端推送消息，客户端也可以主动向服务端发送消息，是真正的双向平等对话，属于<strong>服务器推送技术</strong>的一种。</p> <p>其他服务器推送技术：</p> <ol><li><p>传统轮询</p> <META HTTP-RQUIV="Refresh" CONTENT="12"><p>http头告诉浏览器每12s刷新一次</p></META></li> <li><p>Ajax轮询</p> <p>每间隔一段时间，ajax请求后端查询是否发生改变</p></li> <li><p>comet长连接</p></li> <li><p>flash xml socket</p></li> <li><p>java applet</p></li></ol> <ul><li><p>websocket对象api</p> <ul><li>构造函数  var ws = new WebSocket('ws://localhost:8080')</li> <li>onopen  连接建立回调</li> <li>onmessage  客户端收到消息回调</li> <li>onclose  连接关闭回调</li> <li>onerror  连接错误回调</li> <li>send  发送消息</li> <li>close  关闭连接</li></ul></li> <li><p>客户端简单示例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 创建websocket连接对象</span>
<span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">&quot;wss://echo.websocket.org&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 连接建立触发回调</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Connection open ...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">// 连接对象发送消息</span>
  ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;Hello WebSockets!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 客户端收到信息触发回调</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Received Message: &quot;</span> <span class="token operator">+</span> evt<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 连接关闭触发回调</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Connection closed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>      
</code></pre></div></li></ul> <h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="header-anchor">#</a> TCP三次握手四次挥手</h2> <blockquote><p><strong>三次握手</strong></p></blockquote> <p>总结：因为客户端和服务器都需要直到<strong>各自可收发</strong>，所以需要三次握手</p> <p><img src="https://cdn.jsdelivr.net/gh/rookiepjx/image-bed/img/Snipaste_2020-08-10_15-46-54.jpg" alt=""></p> <ol><li>第一次握手，s可以确认收到c发送的报文（s可收）</li> <li>第二次握手，c可以确认s收到了自己发送的报文，并确认自己可以收到s发送的报文（c可收发）</li> <li>第三次握手，s可以确认c收到了自己发送的报文（s可发）</li></ol> <p><strong>为什么需要三次握手，不是两次</strong></p> <ul><li><strong>防止重复连接</strong>：如果之前的连接请求在网络中延迟了，并且在连接建立后再次到达服务器，三次握手可以确保不会因此建立多余的连接。</li> <li><strong>确保双方都准备好</strong>：三次握手确保了客户端和服务器都能够接收和发送数据，从而可以开始可靠的数据传输。如果两次，服务端无法确认自己发送的包客户端能否接受到。</li></ul> <blockquote><p><strong>四次挥手</strong></p></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/rookiepjx/image-bed/img/Snipaste_2020-08-10_16-11-31.jpg" alt=""></p> <ol><li><strong>结束（FIN）</strong>：当客户端完成数据传输并准备关闭连接时，它会发送一个带有FIN标志位的TCP段给服务器，请求关闭连接。</li> <li><strong>结束确认（ACK）</strong>：服务器收到FIN后，发送一个ACK段作为响应，表示已经收到了关闭请求。</li> <li><strong>结束（FIN）</strong>：服务器在完成数据传输后，也会发送一个带有FIN标志位的TCP段给客户端，请求关闭它的连接端。</li> <li><strong>结束确认（ACK）</strong>：客户端收到服务器的FIN后，发送一个ACK段作为最终响应，表示连接可以关闭。</li></ol> <p><strong>为什么需要四次挥手？</strong></p> <p>总结：需要把所有数据发完，才能确认释放连接。所以第二次握手先发一个ack告诉客户端收到释放请求。所有数据发完，第三次握手再发FIN释放。</p> <ul><li><strong>全双工通信</strong>：TCP连接是全双工的，这意味着数据可以在两个方向上独立传输。因此，每个方向上的连接都需要单独关闭。</li> <li><strong>确保数据传输完成</strong>：四次挥手确保双方都有机会发送完剩余的数据，并确认对方已经接收到所有数据。</li> <li><strong>有序关闭</strong>：通过四次挥手，TCP确保连接可以有序地关闭，避免数据丢失或错误。</li></ul> <h2 id="tcp和udp"><a href="#tcp和udp" class="header-anchor">#</a> TCP和UDP</h2> <table><thead><tr><th></th> <th>TCP</th> <th>UDP</th></tr></thead> <tbody><tr><td>面向连接</td> <td>面向连接</td> <td>无连接，发送数据前不需要建立连接</td></tr> <tr><td>可靠性</td> <td>可靠。无差错，不丢失，不重复，按序到达。流量控制、拥塞控制</td> <td>不保证可靠交付</td></tr> <tr><td>传输单位</td> <td>面向字节流</td> <td>面向报文</td></tr> <tr><td>连接数</td> <td>1对1</td> <td>1对1和1对多</td></tr> <tr><td>首部大小</td> <td>20字节</td> <td>8字节</td></tr></tbody></table> <p><strong>视频通话使用UDP</strong>的原因： 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些<strong>实时性</strong>要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p> <h2 id="tcp的可靠交付"><a href="#tcp的可靠交付" class="header-anchor">#</a> TCP的可靠交付</h2> <p>可靠交付基于ARQ协议和滑动窗口协议。</p> <p><strong>ARQ 协议</strong>指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的 机制。</p> <ol><li>滑动窗口协议</li></ol> <p>使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发 送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分 组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没 有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分 组。</p> <p>接收方使用的是<strong>累计确认</strong>的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那 么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了， 所以发送窗口可以移动到已确认分组的后面。</p> <p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况 的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。</p> <ol start="2"><li>选择重传协议</li></ol> <p>因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。</p> <p>选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组， 已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协 议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的 定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分 组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。</p> <p>在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分 组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。</p> <h2 id="tcp的流量控制"><a href="#tcp的流量控制" class="header-anchor">#</a> TCP的流量控制</h2> <p>TCP 提供了流量控制的服务，这个服务的主要目的是<strong>控制发送方的发送速率</strong>，保证接收方来得及接收。因为一旦发送的速率大 于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，<strong>发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</strong></p> <h2 id="tcp的拥塞控制"><a href="#tcp的拥塞控制" class="header-anchor">#</a> TCP的拥塞控制</h2> <p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就<strong>减小发送的速率</strong>，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p> <p>TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。</p> <ul><li><p><strong>慢启动</strong>的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达 到一个阈值的时候就进入拥塞避免算法。</p></li> <li><p><strong>拥塞避免</strong>算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。</p></li> <li><p><strong>快速重传</strong>指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的 丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p></li> <li><p><strong>快速恢复</strong>是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p></li></ul> <h2 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> http状态码</h2> <p>1xx	信息状态码</p> <p>2xx	成功状态码</p> <p>3xx	重定向状态码</p> <p>4xx	客户端错误状态码</p> <p>5xx	服务器错误状态码</p> <table><thead><tr><th>状态码</th> <th>信息</th></tr></thead> <tbody><tr><td>100</td> <td>继续</td></tr> <tr><td>101</td> <td>切换协议</td></tr> <tr><td>200</td> <td>请求成功</td></tr> <tr><td>300</td> <td><code>Multiple Choices</code>：多重选择，请求有多个可能的响应</td></tr> <tr><td>301</td> <td><code>Moved Permanently</code>：永久重定向</td></tr> <tr><td>302</td> <td><code>Found</code>：临时重定向，通过<code>Location</code>响应头确定重定向的地址</td></tr> <tr><td>304</td> <td><code>Not Modified</code> ：内容被缓存了未改变</td></tr> <tr><td>400</td> <td><code>Bad Request</code>： 客户端请求的语法错误，服务器无法理解</td></tr> <tr><td>401</td> <td><code>Unauthorized</code>：要求身份认证</td></tr> <tr><td>403</td> <td><code>Forbidden</code>：服务器理解请求但拒绝执行</td></tr> <tr><td>404</td> <td><code>Not Found</code>：资源找不到</td></tr> <tr><td>405</td> <td><code>Method Not Allowed</code>：请求的方法不被允许</td></tr> <tr><td>500</td> <td><code>Internal Server Error</code>：服务器内部错误</td></tr> <tr><td>501</td> <td><code>Not Implemented</code>：服务器不支持请求的功能，无法完成请求</td></tr> <tr><td>502</td> <td><code>Bad Gateway</code>：作为网关或代理工作的服务器从上游服务器收到无效响应</td></tr> <tr><td>503</td> <td><code>Service Unavailable</code>：服务器目前无法使用（由于超载或停机维护）</td></tr> <tr><td>504</td> <td><code>Gateway Timeout</code>：作为网关或代理的服务器，未能及时从上游服务器接收请求</td></tr> <tr><td>505</td> <td><code>HTTP Version Not Supported</code>：服务器不支持请求的HTTP协议版本</td></tr></tbody></table> <h2 id="浏览器存储"><a href="#浏览器存储" class="header-anchor">#</a> 浏览器存储</h2> <blockquote><p>cookie	sessionStorage	localStorage</p></blockquote> <table><thead><tr><th></th> <th>cookie</th> <th>sessionStorage</th> <th>localStorage</th></tr></thead> <tbody><tr><td>生命周期</td> <td>设置的有效期内存在，即使浏览器关闭。默认关闭浏览器失效</td> <td>会话窗口，浏览器关闭失效</td> <td>持久存在，即使浏览器关闭</td></tr> <tr><td>传输</td> <td>同源http请求中携带，在c/s端来回传输，即使不需要</td> <td>本地保存，不传输</td> <td>本地保存，不传输</td></tr> <tr><td>大小</td> <td>容量小，4k</td> <td>容量大，5M或更多</td> <td>容量大，5M或更多</td></tr> <tr><td>共享性</td> <td>同源窗口共享</td> <td>会话跳转的页面可以共享sessionStorage</td> <td>同源窗口共享</td></tr></tbody></table> <h2 id="get和post"><a href="#get和post" class="header-anchor">#</a> Get和Post</h2> <p><strong>误区：http协议并未规定get和post的请求长度限制</strong></p> <p>Get的最大长度是<strong>浏览器和服务器限制</strong>的。不同浏览器有不同的长度限制。</p> <table><thead><tr><th></th> <th>get</th> <th>post</th></tr></thead> <tbody><tr><td>后退/刷新</td> <td>无害</td> <td>数据会被重新提交</td></tr> <tr><td>书签</td> <td>可收藏为书签</td> <td>不可收藏为书签</td></tr> <tr><td>缓存</td> <td>能被缓存</td> <td>不能缓存</td></tr> <tr><td>编码类型</td> <td>application/x-www-form-urlencoded</td> <td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr> <tr><td>历史</td> <td>参数保留在浏览器历史中。</td> <td>参数不会保存在浏览器历史中。</td></tr> <tr><td>对数据长度的限制</td> <td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td> <td>无限制。</td></tr> <tr><td>对数据类型的限制</td> <td>只允许 ASCII 字符。</td> <td>没有限制。也允许二进制数据。</td></tr> <tr><td>安全性</td> <td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td> <td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr> <tr><td>可见性</td> <td>数据在 URL 中对所有人都是可见的。</td> <td>数据不会显示在 URL 中。</td></tr></tbody></table> <h2 id="在地址栏输入url回车后-都发生了什么"><a href="#在地址栏输入url回车后-都发生了什么" class="header-anchor">#</a> 在地址栏输入URL回车后，都发生了什么？</h2> <p><img src="https://cdn.jsdelivr.net/gh/rookiepjx/image-bed/img/Snipaste_2020-12-05_16-28-05.jpg" alt=""></p> <ol><li><strong>解析URL</strong></li></ol> <p>URL主要由以下几个部分组成：</p> <p><strong>- a.传输协议 - b.服务器 - c.域名 - d.端口 - e.虚拟目录 - f.文件名 - g.锚 - h.参数</strong></p> <p>例如 [https://baike.baidu.com:80/item/HTML?fr=aladdin#4_1]</p> <p>当在浏览器中输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段。</p> <ol start="2"><li><strong>DNS域名解析</strong></li></ol> <p>通过域名和IP地址一一对应，找到IP地址。</p> <ul><li>查询浏览器DNS缓存</li> <li>查询操作系统缓存</li> <li>查询hosts文件</li> <li>查询路由缓存</li> <li>向域名服务器发送请求查询</li></ul> <p>获取到域名对应的IP后，向该IP地址定位的HTTP服务器发起TCP连接</p> <ol start="3"><li><p><strong>浏览器与网站建立TCP连接（三次握手）</strong></p></li> <li><p><strong>请求和发送数据</strong></p></li> <li><p><strong>浏览器渲染页面</strong></p></li></ol> <ul><li><p>解析html文件，<strong>创建DOM树</strong></p></li> <li><p>解析css文件，形成<strong>css对象模型CSSOM</strong></p></li> <li><p><strong>利用DOM和CSSOM构建一个渲染树（rendering tree）。</strong> 渲染树和DOM树有点像，但是是有区别的。</p> <p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。</p></li></ul> <ol start="6"><li>浏览器根据**渲染树（rendering tree）**绘制页面</li></ol> <h2 id="csrf和xss网络攻击和防范"><a href="#csrf和xss网络攻击和防范" class="header-anchor">#</a> CSRF和XSS网络攻击和防范</h2> <p><strong>CSRF 跨站请求伪造</strong></p> <p>Cross-site request forgery</p> <p>利用了用户已经认证的身份在不知情的情况下向服务器发送恶意请求。</p> <p>CSRF攻击通常发生在用户已经登录了一个网站，并且该网站的会话信息（如Cookie）存储在浏览器中的情况下</p> <p><strong>防范</strong></p> <ol><li><p>CSRF Token验证（常用） axios支持该功能</p></li> <li><p>设置Cookie的SameSite属性，限制Cookie在跨站请求中的发送</p></li> <li><p>Referer请求头验证，确保请求是从合法的来源发起的</p></li> <li><p>CSP内容安全策略</p> <ul><li><p>服务器设置<code>Content-Security-Policy</code>响应头</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self';
</code></pre></div></li> <li><p>前端设置<code>meta标签</code></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'; style-src 'self';&quot;&gt;
</code></pre></div></li></ul></li></ol> <p><strong>XSS 跨站脚本攻击</strong></p> <p>Cross Site Scripting（XSS是为了区别于CSS）</p> <p>1、<strong>反射型</strong></p> <p>当用户输入的数据未经适当处理或过滤，就被用在URL形成<strong>恶意链接</strong>，被浏览器解析为HTML或JavaScript实施攻击。这个过程像一次反射，所以叫反射型XSS。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>http://127.0.0.1:5000/index.html?a=&lt;script&gt;alert(123)&lt;/script&gt;
</code></pre></div><p>2、<strong>存储型</strong></p> <p>恶意脚本被存储在目标服务器上（例如，数据库、消息论坛、访客留言等），当其他用户访问存储该脚本的页面时，脚本被执行。</p> <p>3、<strong>DOM型</strong></p> <p>当Web页面的Document Object Model（DOM）被JavaScript修改，且修改是基于用户的输入，而输入数据未被妥善处理时发生</p> <p><strong>防范</strong></p> <ol><li>输入过滤，确保不允许执行任何脚本</li> <li>输出编码，进行HTML编码，防止浏览器将其解释为代码</li> <li>使用安全API，如<code>textContent</code>而不是<code>innerHTML</code>，以减少XSS风险</li> <li>设置cookie的<strong>HttpOnly</strong>属性以避免cookie劫持</li> <li>内容安全策略（CSP）</li> <li>限制字符串长度。xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。</li></ol> <p><strong>CSRF 和 XSS 区别</strong></p> <p>区别一：</p> <p>CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。</p> <p>区别二：（原理的区别）</p> <p>CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <ul><li><p>原因：处于安全考虑，浏览器有同源限制策略，导致跨域问题。</p> <p>同源：<strong>协议名 域名 端口号 一致</strong></p></li> <li><p>解决方法</p> <ul><li>JSONP(只支持get)</li> <li>CROS 前后端协作设置请求头部<code>access-control-origin-allow:/*</code></li> <li>H5的WebSocket</li> <li>H5的postMessage</li></ul></li> <li><p>JSONP</p></li></ul> <p><strong>实现原理</strong>：浏览器对于<code>script</code>、<code>img</code>、<code>iframe</code>等标签的src属性没有进行同源限制，所以可以通过<code>script</code>标签的src属性发送请求。</p> <p>利用html中script标签的src属性，来请求外部链接，当请求外部链接的时候，通过在url的后面加个回调函数的名字，后端会返回这个回调函数的执行，从而实现跨域</p> <p>示例代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">showJsonp</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://127.0.0.1:8787/?func=showJsonp'</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span><span class="token string">'text/javascript'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 后端代码</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> callback <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>func<span class="token punctuation">;</span>
  <span class="token keyword">let</span> content <span class="token operator">=</span> callback<span class="token operator">+</span><span class="token string">&quot;({'message':'测试数据2'})&quot;</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>结果浏览器执行<code>showJonp({'message':'测试数据2'})</code>,控制台打印<code>测试数据2</code></p> <p><strong>优点</strong>：对于浏览器的兼容性好</p> <p><strong>缺点</strong>：只支持跨域的get请求</p> <ul><li>CROS</li></ul> <p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing），属于跨源 AJAX 请求的根本解决方法</p> <p><strong>方法1</strong>：后端设置请求头</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Origin：'域名或者通配符*'
</code></pre></div><p><strong>方法2</strong>：在Nginx的配置文件中加上以下代码</p> <div class="language- extra-class"><pre class="language-text"><code>location /api/ { #这里设置了/api，那么前端在请求时的基础路径就得加上/api
    proxy_pass http://127.0.0.1:4000/;#这里指的是你的服务器运行在哪个端口
}
</code></pre></div><p><strong>方法3</strong>：前端VUE或者REACT设置代理</p> <p>这里只拿Vue来举例子
在vue.config.js这个配置文件中加上</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  devServer: {
    open: true,
    proxy: {
      '/api': { // 匹配所有以'/api'开头的请求路径
        target: 'http://target.com', // 代理目标的基础路径
        changeOrigin: true, // 支持跨域
        pathRewrite: { // 重写路径: 去掉路径开头的'/api'
          '^/api': ''
        }
      }
    }
  },
}
</code></pre></div><p><strong>优点</strong>：简单，更安全，支持post请求</p> <p><strong>缺点</strong>：兼容性差，只支持IE10以上</p> <h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h2> <p><strong>强制缓存</strong></p> <p>当使用强制缓存策略时，客户端会直接访问本地缓存，存在则直接返回；不存在则向服务器发送请求，响应后再存入缓存。</p> <p>开启强制缓存，可以添加<strong>响应头字段:Expire和Catch-control</strong></p> <ul><li><p><code>Expire</code></p> <p><strong>http1.0</strong>中提出，通过<strong>绝对时间</strong>表示缓存到期时间。在过期时间之前，都使用缓存。</p> <div class="language- extra-class"><pre class="language-text"><code>Expires: Thu, 10 Nov 2017 08:45:11 GMT
</code></pre></div><p>缺点：</p> <ol><li>绝对时间的表示方法，可能由于被本地修改或者时差导致缓存失效</li> <li>表示方法复杂</li></ol></li> <li><p><code>Catch-control</code></p> <p>为解决expire的缺点，<strong>http1.1</strong>提出catch-control响应头字段。通过<strong>相对时间</strong>表示缓存过期时间。</p> <div class="language- extra-class"><pre class="language-text"><code>Cache-control: max-age=2592000
</code></pre></div><p>常用值：max-age、no-catch、no-store等</p> <p>no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求</p></li></ul> <p><strong>注意</strong>：当两个响应头同时存在，<strong>Cache-control的优先级高于Expires</strong>（http1.1&gt;http1.0）</p> <p><strong>协商缓存</strong></p> <p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 <strong>304</strong> 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p> <p>开启协商缓存，可以设置<strong>响应头字段的Etag 和 Last-Modified</strong></p> <ul><li><p><code>Last-modified</code></p> <p>服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 <strong>If-Modified-Since</strong> 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。</p> <p>缺点：单位精确到秒，如果1秒内缓存被多次修改，会失效。</p></li> <li><p><code>Etag</code></p> <p>为避免Last-modified的不精确性，Etag返回唯一标识符，通常是<strong>hash值</strong>。当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 <strong>If-None-Match</strong> 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。</p></li></ul> <p><strong>注意</strong>：当两个响应头同时存在，<strong>Etag的优先级高于Last-Modified</strong></p> <p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5ab2ec69.js" defer></script><script src="/assets/js/2.eeb24f79.js" defer></script><script src="/assets/js/10.d0415309.js" defer></script>
  </body>
</html>
